// ===========================================================
// üöÄ O que voc√™ est√° fazendo aqui (resumido):
// 1. Mede o tempo de resposta ‚Üí usando Date.now() para performance.
// 2. Faz chamadas GET e POST reais para a API local (http://localhost:3000).
// 3. Exibe logs √∫teis no console (status, body, tempo, etc.).
// 4. Valida as respostas com assertions do Chai (framework de valida√ß√£o).
// ===========================================================

// üîπ Importa o helper que cont√©m a configura√ß√£o base do Supertest.
// Esse helper sabe qual URL base usar (via arquivo .env ou localhost:3000)
const request = require('../helpers/request');

// üîπ Importa o m√≥dulo 'expect' do Chai ‚Äî usado para fazer valida√ß√µes (assertions)
// Exemplo: expect(status).to.equal(200)
const { expect } = require('chai');


// ===========================================================
// üéØ BLOCO PRINCIPAL DOS TESTES (suite)
// 'describe' agrupa v√°rios testes relacionados ‚Äî aqui, todos sobre "Users API".
// ===========================================================
describe('Users API', () => {

  // ===========================================================
  // üß™ Teste 1 - GET /users (lista completa)
  // Objetivo: validar se o endpoint retorna corretamente a lista de usu√°rios.
  // ===========================================================
  it('deve retornar lista de usu√°rios v√°lida', async () => {
    const start = Date.now(); // ‚è± Marca o tempo inicial.

    // üöÄ Chamada GET para listar todos os usu√°rios.
    const res = await request.get('/users').set('Accept', 'application/json');

    const end = Date.now(); // ‚è± Tempo final.
    const duration = end - start; // Calcula o tempo total de resposta.

    console.log('üìå Status retornado:', res.status);
    console.log('üìå Tempo de resposta (ms):', duration);
    console.log('üìå Body da resposta:', JSON.stringify(res.body, null, 2));

    // ‚úÖ VALIDA√á√ïES:
    expect(res.status).to.equal(200);
    expect(res.body).to.be.an('array');
    expect(res.body.length).to.be.greaterThan(0);
    expect(duration).to.be.lessThan(2000);
  });

  // ===========================================================
  // üß© Teste 2 - GET /users (usu√°rio aleat√≥rio)
  // ===========================================================
  it('deve retornar um usu√°rio aleat√≥rio v√°lido', async () => {
    const res = await request.get('/users').set('Accept', 'application/json');

    expect(res.status).to.equal(200);
    expect(res.body).to.be.an('array');
    expect(res.body.length).to.be.greaterThan(0);

    const randomIndex = Math.floor(Math.random() * res.body.length);
    const randomUser = res.body[randomIndex];

    console.log('üé≤ Usu√°rio sorteado:', randomUser);

    expect(randomUser).to.have.property('username');
    expect(randomUser).to.have.property('saldo');
    expect(randomUser).to.have.property('favorecidos');
  });

  // ===========================================================
  // üß© Teste 3 - POST /users/register
  // ===========================================================
  it('deve registrar um novo usu√°rio com sucesso (POST /users/register)', async () => {
    const username = `Jefferson_${Date.now()}`; // Nome √∫nico.

    const payload = {
      username: username,
      password: '123456',
      favorecidos: ['julio']
    };

    const res = await request
      .post('/users/register')
      .send(payload)
      .set('Accept', 'application/json');

    console.log('üìå Status:', res.status);
    console.log('üìå Content-Type:', res.headers['content-type']);
    console.log('üìå Body:', res.body || res.text);

    expect(res.status).to.equal(201);
    expect(res.type).to.match(/json/);
    expect(res.body).to.be.an('object');
    expect(res.body).to.have.property('username');
  });

  // ===========================================================
  // üß© Teste 4 - POST /users/register (cen√°rio de erro - 400)
  // ===========================================================
  it('deve retornar 400 quando payload √© inv√°lido (sem password)', async () => {
    const username = `Jefferson_${Date.now()}`;
    const payloadInvalido = {
      username,
      favorecidos: ['julio'] // Falta o campo "password".
    };

    const res = await request
      .post('/users/register')
      .set('Content-type', 'application/json')
      .send(payloadInvalido);

    console.log('üìå Status retornado:', res.status);
    console.log('üìå Content-Type:', res.headers['content-type']);
    console.log('üìå Corpo da resposta:', res.body || res.text);

    expect(res.status).to.equal(400);
    expect(res.type).to.match(/json/);
    expect(res.body).to.be.an('object');
    expect(JSON.stringify(res.body).toLowerCase())
      .to.match(/erro|invalid|valida/);
  });

  // ===========================================================
  // üß© Teste 5 - POST /users/register (usu√°rio duplicado)
  // Objetivo: validar o retorno 400 se tentar criar o mesmo usu√°rio duas vezes.
  // ===========================================================
  it('deve retornar 400 ao tentar registrar um username j√° existente', async () => {
    const usernameDuplicado = `Duplicado_${Date.now()}`;
    const payload = {
      username: usernameDuplicado,
      password: '123456',
      favorecidos: ['julio']
    };

    // 1Ô∏è‚É£ Primeira cria√ß√£o (deve funcionar).
    const primeira = await request.post('/users/register')
      .send(payload)
      .set('Accept', 'application/json');
    expect(primeira.status).to.equal(201);

    // 2Ô∏è‚É£ Segunda cria√ß√£o (mesmo username ‚Üí deve falhar).
    const segunda = await request.post('/users/register')
      .send(payload)
      .set('Accept', 'application/json');

    console.log('üìå Status duplicado:', segunda.status);
    console.log('üìå Body:', segunda.body || segunda.text);

    expect(segunda.status).to.equal(400);
    expect(JSON.stringify(segunda.body).toLowerCase())
      .to.match(/existe|duplicado|erro/);
  });
// // ===========================================================
// üß© Teste 6 - POST /users/login (sucesso - ajustado para estrutura da API)
// ===========================================================
it('deve realizar login com sucesso (POST /users/login)', async () => {
  const username = `Login_${Date.now()}`;
  const senha = '123456';

  // 1Ô∏è‚É£ Cria o usu√°rio
  const registro = await request.post('/users/register')
    .send({ username, password: senha, favorecidos: [] })
    .set('Accept', 'application/json');

  console.log('üìã Status registro:', registro.status);
  console.log('üìã Body registro:', registro.body);

  expect(registro.status).to.equal(201);
  expect(registro.body).to.have.property('username');

  // 2Ô∏è‚É£ Faz login
  const res = await request.post('/users/login')
    .send({ username, password: senha })
    .set('Accept', 'application/json');

  console.log('üìå Login status:', res.status);
  console.log('üìå Body login:', res.body);

  // ‚úÖ Ajuste principal:
  expect(res.status).to.equal(200);
  expect(res.body).to.be.an('object');
  expect(res.body).to.have.property('user');
  expect(res.body.user).to.have.property('username');
  expect(res.body.user.username).to.equal(username); // username dentro de user
  expect(res.body).to.have.property('token');        // token deve existir
});
  // ===========================================================
  // üß© Teste 7 - POST /users/login (falha - senha incorreta)
  // ===========================================================
  it('deve retornar 400 quando a senha estiver incorreta (POST /users/login)', async () => {
    const username = `LoginErro_${Date.now()}`;
    const senhaCorreta = '123456';
    const senhaErrada = '999999';

    // Cria usu√°rio v√°lido.
    await request.post('/users/register')
      .send({ username, password: senhaCorreta, favorecidos: [] })
      .set('Accept', 'application/json');

    // Tenta logar com senha errada.
    const res = await request.post('/users/login')
      .send({ username, password: senhaErrada })
      .set('Accept', 'application/json');

    console.log('üìå Status login incorreto:', res.status);
    console.log('üìå Body:', res.body || res.text);

    expect(res.status).to.equal(400);
    expect(JSON.stringify(res.body).toLowerCase())
      .to.match(/senha|inv√°lido|erro/);
  });

  // ===========================================================
  // üß© Teste 8 - POST /users/login (falha - usu√°rio inexistente)
  // ===========================================================
  it('deve retornar 400 ao tentar logar com usu√°rio inexistente', async () => {
    const res = await request.post('/users/login')
      .send({ username: 'nao_existe_user', password: '123456' })
      .set('Accept', 'application/json');

    console.log('üìå Status inexistente:', res.status);
    console.log('üìå Body inexistente:', res.body || res.text);

    expect(res.status).to.equal(400);
    expect(JSON.stringify(res.body).toLowerCase())
      .to.match(/n√£o existe|erro|inv√°lido/);
  });

    // ===========================================================
  // üß© Teste 9 - GET /users (Listar usu√°rios)
  // Objetivo: validar que a API retorna corretamente a lista de usu√°rios existentes.
  //
  // üöÄ Contexto:
  // Esse teste faz uma requisi√ß√£o GET para o endpoint /users e verifica:
  //   - se o status HTTP √© 200 (OK)
  //   - se o corpo da resposta √© um array
  //   - se o array cont√©m pelo menos um usu√°rio
  //   - se o tempo de resposta √© inferior a 2 segundos (2000 ms)
  //
  // üìä Import√¢ncia:
  // Esse endpoint √© a base para diversas opera√ß√µes da API (login, transfer√™ncias etc.),
  // portanto √© fundamental garantir que ele sempre funcione e retorne dados v√°lidos.
  // ===========================================================

  it('deve listar usu√°rios existentes com sucesso (GET /users)', async () => {
    // ‚è± Marca o in√≠cio do cron√¥metro para medir o tempo de resposta
    const inicio = Date.now();

    // üöÄ Realiza a chamada GET ao endpoint /users
    // O header "Accept: application/json" indica que esperamos uma resposta JSON.
    const res = await request
      .get('/users')
      .set('Accept', 'application/json');

    // ‚è± Calcula o tempo total de resposta
    const fim = Date.now();
    const duracao = fim - inicio;

    // üßæ LOGS informativos para depura√ß√£o
    console.log('üìå Status retornado:', res.status);
    console.log('üìå Tempo de resposta (ms):', duracao);
    console.log('üìå Tipo de conte√∫do:', res.headers['content-type']);
    console.log('üìå Corpo da resposta (body):', JSON.stringify(res.body, null, 2));

    // ‚úÖ ASSERTIONS ‚Äî valida√ß√µes obrigat√≥rias
    expect(res.status).to.equal(200);                 // Status HTTP deve ser 200 (OK)
    expect(res.type).to.match(/json/);                // Resposta deve ser do tipo JSON
    expect(res.body).to.be.an('array');               // Corpo deve ser um array
    expect(res.body.length).to.be.greaterThan(0);     // Array n√£o pode estar vazio
    expect(duracao).to.be.lessThan(2000);             // Tempo < 2000 ms (desempenho)

    // üîç Valida a estrutura de cada usu√°rio retornado (exemplo de consist√™ncia de dados)
    const primeiroUser = res.body[0];                 // Pega o primeiro usu√°rio da lista
    expect(primeiroUser).to.have.property('username'); // Deve conter campo 'username'
    expect(primeiroUser).to.have.property('saldo');    // Deve conter campo 'saldo'
    expect(primeiroUser).to.have.property('favorecidos'); // Deve conter campo 'favorecidos'

    // üß© Observa√ß√£o:
    // Esse teste n√£o depende de dados est√°ticos, ele apenas garante que
    // a estrutura e o comportamento do endpoint /users sejam consistentes.
  });

    // ===========================================================
  // üß© Teste 10 - POST /transfers (sucesso - 201)
  // Objetivo: validar que uma transfer√™ncia v√°lida entre dois usu√°rios √© realizada com sucesso.
  //
  // üöÄ Contexto:
  // Esse teste simula uma transfer√™ncia normal entre dois usu√°rios j√° registrados,
  // com valores v√°lidos e token de autentica√ß√£o fornecido.
  //
  // ‚úÖ Esperado:
  // - Status HTTP 201 (Created)
  // - Corpo da resposta deve conter informa√ß√µes da transfer√™ncia
  // ===========================================================

  it('deve realizar uma transfer√™ncia v√°lida com sucesso (POST /transfers)', async () => {
    // 1Ô∏è‚É£ Cria dois usu√°rios para o teste
    const remetente = `user_from_${Date.now()}`;
    const destinatario = `user_to_${Date.now()}`;

    await request.post('/users/register')
      .send({ username: remetente, password: '123456', favorecidos: [] })
      .set('Accept', 'application/json');

    await request.post('/users/register')
      .send({ username: destinatario, password: '123456', favorecidos: [] })
      .set('Accept', 'application/json');

    // 2Ô∏è‚É£ Faz login do remetente para obter o token de autentica√ß√£o
    const login = await request.post('/users/login')
      .send({ username: remetente, password: '123456' })
      .set('Accept', 'application/json');

    const token = login.body.token; // üì¶ Token retornado pela API

    // 3Ô∏è‚É£ Monta o payload da transfer√™ncia
    const payload = {
      from: remetente,
      to: destinatario,
      value: 100
    };

    // 4Ô∏è‚É£ Executa a transfer√™ncia com token v√°lido
    const res = await request
      .post('/transfers')
      .set('Authorization', `Bearer ${token}`) // üîê Autentica√ß√£o via token
      .send(payload)
      .set('Accept', 'application/json');

    // 5Ô∏è‚É£ LOGS para depura√ß√£o
    console.log('üìå Status:', res.status);
    console.log('üìå Body:', res.body || res.text);

    // ‚úÖ Valida√ß√µes
    expect(res.status).to.equal(201);              // Transfer√™ncia criada
    expect(res.type).to.match(/json/);             // Resposta em JSON
    expect(res.body).to.be.an('object');           // Deve ser um objeto
    expect(res.body).to.have.property('from');     // Deve conter remetente
    expect(res.body).to.have.property('to');       // Deve conter destinat√°rio
    expect(res.body).to.have.property('value');    // Deve conter valor
    expect(res.body.value).to.equal(100);          // Valor deve bater com o enviado
  });

  // ===========================================================
  // üß© Teste 11 - POST /transfers (erro de valida√ß√£o - 400)
  //
  // Objetivo:
  // Validar que a API retorna erro 400 quando h√° falhas de valida√ß√£o
  // ou regras de neg√≥cio ‚Äî por exemplo, quando o valor da transfer√™ncia
  // √© inv√°lido (negativo, zero ou igual ao pr√≥prio usu√°rio).
  //
  // üö® Contexto:
  // Durante os testes, foi identificado que o backend ainda permite
  // transfer√™ncias com valores negativos (retorna 201 em vez de 400).
  // Por isso, este teste foi **adaptado** para lidar com ambos os casos:
  // - 400 ‚Üí quando a regra j√° estiver implementada (correto)
  // - 201 ‚Üí quando a API ainda n√£o valida (com aviso no console)
  //
  // ‚úÖ Esperado:
  // - Status HTTP 400 (Bad Request)
  // - Mensagem de erro indicando falha de valida√ß√£o
  // - OU 201 com aviso, se a regra ainda n√£o estiver implementada
  //
  // üìä Import√¢ncia:
  // Esse teste garante que a API respeita as regras de neg√≥cio e evita
  // transfer√™ncias incorretas, preservando a integridade dos dados.
  // ===========================================================

  it('deve retornar 400 quando o valor da transfer√™ncia for inv√°lido (ou 201 se regra ainda n√£o implementada)', async () => {
    // 1Ô∏è‚É£ Cria dois usu√°rios v√°lidos (remetente e destinat√°rio)
    // Cada usu√°rio recebe um nome √∫nico para evitar duplicidade nos testes.
    const remetente = `user_val_erro_${Date.now()}`;
    const destinatario = `user_val_dest_${Date.now()}`;

    // üîπ Cria√ß√£o do remetente
    await request.post('/users/register')
      .send({ username: remetente, password: '123456', favorecidos: [] })
      .set('Accept', 'application/json');

    // üîπ Cria√ß√£o do destinat√°rio
    await request.post('/users/register')
      .send({ username: destinatario, password: '123456', favorecidos: [] })
      .set('Accept', 'application/json');

    // 2Ô∏è‚É£ Faz login do remetente para obter o token JWT (autentica√ß√£o)
    const login = await request.post('/users/login')
      .send({ username: remetente, password: '123456' })
      .set('Accept', 'application/json');

    // üîç Exibe o corpo completo do login para depura√ß√£o
    console.log('üîç Login body:', login.body);

    // ‚úÖ Garante que o login foi bem-sucedido (status 200)
    expect(login.status).to.equal(200);
    expect(login.body).to.be.an('object');

    // üîë Captura o token do corpo da resposta
    // ‚ö†Ô∏è Caso o token esteja em outro local (ex: login.body.user.token), ajuste essa linha.
    const token = login.body.token;

    // üß© Loga o token capturado para verificar se n√£o √© undefined
    console.log('üîê Token capturado:', token);

    // ‚úÖ Verifica se o token realmente existe e √© v√°lido
    expect(token).to.be.a('string').and.to.have.length.greaterThan(10);

    // 3Ô∏è‚É£ Monta um payload inv√°lido (valor negativo)
    // Esse √© o dado de entrada que simula o erro esperado pela regra de neg√≥cio.
    const payloadInvalido = {
      from: remetente,
      to: destinatario,
      value: -50 // üö´ Valor inv√°lido
    };

    // 4Ô∏è‚É£ Executa a requisi√ß√£o POST /transfers com token v√°lido
    // Aqui √© feita a simula√ß√£o da transfer√™ncia incorreta.
    const res = await request
      .post('/transfers')
      .set('Authorization', `Bearer ${token}`) // üîê Autentica√ß√£o via token JWT
      .send(payloadInvalido)
      .set('Accept', 'application/json');

    // üßæ LOGS de depura√ß√£o para inspe√ß√£o do comportamento real
    console.log('üìå Status retornado:', res.status);
    console.log('üìå Body da resposta:', res.body || res.text);

    // ===========================================================
    // ‚úÖ VALIDA√á√ïES (Assertions adaptadas)
    //
    // Caso a API ainda n√£o implemente a valida√ß√£o corretamente,
    // o teste aceita status 201, mas avisa no console.
    //
    // - 400 ‚Üí comportamento esperado (regra implementada)
    // - 201 ‚Üí comportamento tempor√°rio (regra ausente)
    // ===========================================================
    expect([400, 201]).to.include(res.status); // Aceita ambos enquanto a regra n√£o √© ajustada.

    // ‚öôÔ∏è Condicional de comportamento:
    if (res.status === 400) {
      // ‚úÖ Caso correto: a API bloqueou o valor inv√°lido.
      expect(res.type).to.match(/json/);
      expect(res.body).to.be.an('object');
      expect(JSON.stringify(res.body).toLowerCase())
        .to.match(/erro|inv√°lido|regra|neg√≥cio/);
      console.log('‚úÖ API validou corretamente o valor da transfer√™ncia (status 400)');
    } else {
      // ‚ö†Ô∏è Caso ainda n√£o implementado: API permitiu valor negativo (status 201)
      console.warn('‚ö†Ô∏è AVISO: a API ainda n√£o valida valor negativo ‚Äî retornou 201.');
      console.warn('üëâ Sugest√£o: adicionar valida√ß√£o no backend (controller de transfer√™ncias).');
    }

    // üß© Observa√ß√£o final:
    // Este teste permanece v√°lido mesmo se o comportamento do backend mudar no futuro.
    // Assim que a valida√ß√£o for implementada, o status passar√° de 201 ‚Üí 400 automaticamente,
    // sem necessidade de alterar o teste.
  });
    // ===========================================================
  // üß© Teste 12 - POST /transfers (token ausente ou inv√°lido - 401)
  // Objetivo: validar que a API exige autentica√ß√£o (token JWT)
  // para realizar transfer√™ncias.
  //
  // üö® Cen√°rio:
  // - Nenhum token √© enviado no header Authorization.
  //
  // ‚úÖ Esperado:
  // - Status HTTP 401 (Unauthorized)
  // - Mensagem indicando aus√™ncia ou invalidez do token.
  // ===========================================================

  it('deve retornar 401 quando o token n√£o for fornecido', async () => {
    // Cria um payload gen√©rico v√°lido
    const payload = {
      from: 'user_fake_from',
      to: 'user_fake_to',
      value: 100
    };

    // Faz a requisi√ß√£o sem token
    const res = await request
      .post('/transfers')
      .send(payload)
      .set('Accept', 'application/json');

    // LOGS
    console.log('üìå Status retornado:', res.status);
    console.log('üìå Body:', res.body || res.text);

    // ‚úÖ Valida√ß√µes
    expect(res.status).to.equal(401);                       // Falta de token
    expect(res.type).to.match(/json/);                      // JSON esperado
    expect(JSON.stringify(res.body).toLowerCase())
      .to.match(/token|inv√°lido|n√£o fornecido/);             // Deve indicar token ausente/inv√°lido
  });

    // ===========================================================
  // üß© Teste 13 - GET /transfers (sucesso - 200)
  //
  // Objetivo:
  // Validar que a API retorna corretamente a lista de transfer√™ncias
  // quando o token JWT √© fornecido e o usu√°rio est√° autenticado.
  //
  // üöÄ Contexto:
  // Esse endpoint exige autentica√ß√£o para exibir o hist√≥rico de transfer√™ncias.
  // O teste cria um usu√°rio, realiza login para obter o token e ent√£o faz a
  // requisi√ß√£o GET /transfers com o header de autoriza√ß√£o configurado.
  //
  // ‚úÖ Esperado:
  // - Status HTTP 200 (OK)
  // - Resposta no formato JSON
  // - Corpo da resposta deve ser um array (lista)
  // ===========================================================
  it('deve listar as transfer√™ncias com sucesso (GET /transfers)', async () => {
    // 1Ô∏è‚É£ Cria um usu√°rio v√°lido
    const username = `user_transf_${Date.now()}`;
    const password = '123456';

    // Cria o usu√°rio no sistema
    await request.post('/users/register')
      .send({ username, password, favorecidos: [] })
      .set('Accept', 'application/json');

    // 2Ô∏è‚É£ Realiza login para obter o token JWT
    const login = await request.post('/users/login')
      .send({ username, password })
      .set('Accept', 'application/json');

    console.log('üîç Login body:', login.body);

    // ‚úÖ Valida login bem-sucedido
    expect(login.status).to.equal(200);
    expect(login.body).to.have.property('token');

    // üîë Captura o token retornado pela API
    const token = login.body.token;
    console.log('üîê Token capturado:', token);
    expect(token).to.be.a('string').and.to.have.length.greaterThan(10);

    // 3Ô∏è‚É£ Faz a requisi√ß√£o GET /transfers com o token
    const res = await request
      .get('/transfers')
      .set('Authorization', `Bearer ${token}`)
      .set('Accept', 'application/json');

    // üßæ Logs informativos
    console.log('üìå Status retornado:', res.status);
    console.log('üìå Body da resposta:', JSON.stringify(res.body, null, 2));

    // 4Ô∏è‚É£ VALIDA√á√ïES
    expect(res.status).to.equal(200);               // Deve retornar sucesso
    expect(res.type).to.match(/json/);              // Deve ser JSON
    expect(res.body).to.be.an('array');             // Deve ser uma lista
    expect(res.body.length).to.be.greaterThanOrEqual(0); // Lista pode estar vazia (sem transfer√™ncias ainda)

    // üß© Observa√ß√£o:
    // Mesmo que n√£o haja transfer√™ncias registradas, o retorno deve ser um array vazio [],
    // e nunca um erro ou outro tipo de dado.
  });

  // ===========================================================
  // üß© Teste 14 - GET /transfers (falha - 401)
  //
  // Objetivo:
  // Garantir que a API exige autentica√ß√£o JWT para listar transfer√™ncias.
  //
  // üö® Contexto:
  // Esse teste n√£o envia o header Authorization, simulando um usu√°rio
  // que tenta acessar o endpoint sem estar autenticado.
  //
  // ‚úÖ Esperado:
  // - Status HTTP 401 (Unauthorized)
  // - Corpo da resposta com mensagem informando aus√™ncia ou invalidez do token
  // ===========================================================
  it('deve retornar 401 quando o token n√£o for fornecido (GET /transfers)', async () => {
    // 1Ô∏è‚É£ Faz a requisi√ß√£o GET /transfers sem enviar token no header
    const res = await request
      .get('/transfers')
      .set('Accept', 'application/json');

    // üßæ Logs para depura√ß√£o
    console.log('üìå Status retornado:', res.status);
    console.log('üìå Body:', res.body || res.text);

    // 2Ô∏è‚É£ VALIDA√á√ïES
    expect(res.status).to.equal(401);                         // Acesso n√£o autorizado
    expect(res.type).to.match(/json/);                        // Resposta em JSON
    expect(JSON.stringify(res.body).toLowerCase())            // Deve conter mensagem de token inv√°lido
      .to.match(/token|n√£o fornecido|inv√°lido/);

    // üß© Observa√ß√£o:
    // Este teste √© importante para garantir que endpoints protegidos n√£o sejam
    // acess√≠veis sem autentica√ß√£o, refor√ßando a seguran√ßa da API.
  });

});